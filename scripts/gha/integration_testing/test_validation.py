"""Provides logic for determining results in a C++/Unity testapp.

The initial motivation for this was when sending testapps to Firebase Test Lab.
When using Game Loops, FTL will only report whether the app ran to completion,
i.e. didn't crash or timeout, but is unable to know whether the internal
test runners reported success or failure.

To validate this, the log output is parsed for the test summary generated by
each internal test runner. For C++ this was gTest, for Unity it was a custom
runner. In both cases, the logic works by searching for text indicating the end
of the internal tests, and then parsing the result summary.

In cases where the test summary does not exist (crash, or timeout) a tail of the
log is obtained instead, to help identify where the crash or timeout occurred.

"""

import re

import attr

UNITY = "unity"
CPP = "cpp"


def validate_results(log_text, platform):
  """Determines the results in the log output of a testapp.

  Args:
    log_text (str): Log output from a testapp.
    platform (str): What type of testapp generated the log: 'unity' or 'cpp'.

  Returns:
    (TestResults): Structured results from the log.

  """
  if platform == UNITY:
    return validate_results_unity(log_text)
  elif platform == CPP:
    return validate_results_cpp(log_text)
  else:
    raise ValueError("Invalid platform: %s." % platform)


def validate_results_unity(log_text):
  """Determines the results in the log output of a Unity testapp.

  Args:
    log_text (str): Log output from a Unity testapp.

  Returns:
    (TestResults): Structured results from the log.

  """
  results_match = re.search(
      r"PASS: (?P<pass>[0-9]+), FAIL: (?P<fail>[0-9]+)", log_text)
  match_dict = results_match.groupdict()
  if results_match:
    # After the result string comes a list of failing testapps.
    summary = log_text[results_match.start():]
  else:
    summary = _tail(log_text, 15)
  return TestResults(
      complete=bool(results_match),
      passes=0 if not results_match else int(match_dict["pass"]),
      fails=0 if not results_match else int(match_dict["fail"]),
      skips=0,
      summary=summary)


def validate_results_cpp(log_text):
  """Determines the results in the log output of a C++ testapp.

  Args:
    log_text (str): Log output from a C++ testapp.

  Returns:
    (TestResults): Structured results from the log.

  """
  # The gtest runner dumps a useful summary of tests after the tear down.
  end_marker = "Global test environment tear-down"
  complete = end_marker in log_text

  if complete:
    # rpartition splits a string into three components around the final
    # occurrence of the end marker, returning a triplet (before, marker, after)
    result_summary = log_text.rpartition(end_marker)[2].lstrip()

    passes = re.search(r"\[  PASSED  \] (?P<count>[0-9]+) test", result_summary)
    fails = re.search(r"\[  FAILED  \] (?P<count>[0-9]+) test", result_summary)
    skips = re.search(r"\[  SKIPPED \] (?P<count>[0-9]+) test", result_summary)
  else:
    result_summary = _tail(log_text, 15)

  return TestResults(
      complete=complete,
      passes=0 if not passes else int(passes.group("count")),
      fails=0 if not fails else int(fails.group("count")),
      skips=0 if not skips else int(skips.group("count")),
      summary=result_summary)


def _tail(text, n):
  """Returns the last n lines in text, or all of text if too few lines."""
  return "\n".join(text.splitlines()[-n:])


@attr.s(frozen=True, eq=False)
class TestResults(object):
  complete = attr.ib()  # Did the testapp reach the end, or did it crash/timeout
  passes = attr.ib()
  fails = attr.ib()
  skips = attr.ib()
  summary = attr.ib()  # Test summary from internal runner OR tail of the log
